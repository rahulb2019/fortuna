/// <reference types="node" />
import { TypedEvent } from './util/typed-event';
export declare enum ModbusFunctionCode {
    READ_COIL_STATUS = 1,
    READ_INPUT_STATUS = 2,
    READ_HOLDING_REGISTERS = 3,
    READ_INPUT_REGISTERS = 4,
    FORCE_SINGLE_COIL = 5,
    PRESET_SINGLE_REGISTER = 6,
    FORCE_MULTIPLE_COILS = 15,
    PRESET_MULTIPLE_REGISTERS = 16
}
export declare enum ModbusCommandException {
    ILLEGAL_FUNCTION = 1,
    ILLEGAL_DATA_ADDRESS = 2,
    ILLEGAL_DATA_VALUE = 3,
    SERVER_DEVICE_FAILURE = 4,
    ACKNOWLEDGE = 5,
    SERVER_DEVICE_BUSY = 6,
    NEGATIVE_ACKNOWLEDGE = 7,
    MEMORY_PARITY_ERROR = 8,
    GATEWAY_PATH_UNAVAILABLE = 10,
    GATEWAY_TARGET_FAILED_TO_RESPOND = 11
}
export declare enum CoilStatus {
    ON = 0,
    OFF = 1
}
/**
 * @hidden
 */
export declare type UnitIdGetter = (requestPacket: Buffer) => number;
/**
 * @hidden
 */
export declare type FunctionCodeGetter = (requestPacket: Buffer) => ModbusFunctionCode;
/**
 * @hidden
 */
export declare type CoilAddressGetter = (requestPacket: Buffer) => number;
/**
 * @hidden
 */
export declare type CoilLengthGetter = (requestPacket: Buffer) => number;
/**
 * @hidden
 */
export declare type CoilStatusGetter = (requestPacket: Buffer) => boolean;
/**
 * @hidden
 */
export declare type CoilStatusesGetter = (requestPacket: Buffer) => Array<boolean>;
/**
 * @hidden
 */
export declare type InputAddressGetter = (requestPacket: Buffer) => number;
/**
 * @hidden
 */
export declare type InputLengthGetter = (requestPacket: Buffer) => number;
/**
 * @hidden
 */
export declare type RegisterAddressGetter = (requestPacket: Buffer) => number;
/**
 * @hidden
 */
export declare type RegisterValueGetter = (requestPacket: Buffer) => number;
/**
 * @hidden
 */
export declare type RegisterValuesGetter = (requestPacket: Buffer) => Array<number>;
/**
 * @hidden
 */
export declare type RegisterLengthGetter = (requestPacket: Buffer) => number;
/**
 * @hidden
 */
export declare type GenericSuccessGetter = (requestPacket: Buffer, length?: number) => Buffer;
/**
 * @hidden
 */
export declare type BoolArraySuccessGetter = (reqestPacket: Buffer, data: Array<boolean>) => Buffer;
/**
 * @hidden
 */
export declare type Uint16ArraySuccessGetter = (requestPacket: Buffer, data: Uint16Array) => Buffer;
/**
 * @hidden
 */
export declare type FailureGetter = (requestPacket: Buffer, exception: ModbusCommandException) => Buffer;
export declare abstract class ModbusCommand<T extends ModbusCommand<any>> {
    /**
     * Fires on either success or failure, with the response bytes. Mainly used by the server to send a response.
     */
    onComplete: TypedEvent<ModbusCommand<any>>;
    /**
     * Fires on a call of the success method.
     */
    onSuccess: TypedEvent<ModbusCommand<any>>;
    /**
     * Fires on a call of the fail method.
     */
    onFailure: TypedEvent<ModbusCommand<any>>;
    protected readonly _rawPacket: Buffer;
    protected _responsePacket?: Buffer;
    protected readonly _unitIdGetter: UnitIdGetter;
    protected readonly _functionCodeGetter: FunctionCodeGetter;
    protected readonly _successGetter: GenericSuccessGetter | BoolArraySuccessGetter | Uint16ArraySuccessGetter;
    protected readonly _failureGetter: FailureGetter;
    /**
     * If RTU, unitId is equivalent to slaveId
     */
    readonly unitId: number;
    /**
     * Modbus function code
     */
    readonly functionCode: ModbusFunctionCode;
    /**
     * This function will give you the response packet bytes that will be sent on the emitting server. Before calling this function, the `success` or `fail` method must be called in order to set the response.
     *
     * @returns A buffer of the bytes representing the response to the server
     * @throws ModbusCommandError if success or fail hasn't been called yet
     */
    readonly responsePacket: Buffer;
    protected constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: GenericSuccessGetter | BoolArraySuccessGetter | Uint16ArraySuccessGetter, failureGetter: FailureGetter);
    /**
     * Set a failure on this command to return an exception response to the emitting server.
     *
     * @param exception - The reason for the failure
     */
    fail(exception: ModbusCommandException): void;
}
export declare class ReadCoilStatusCommand extends ModbusCommand<ReadCoilStatusCommand> {
    private readonly _coilAddressGetter;
    private readonly _coilLengthGetter;
    readonly coilStartAddress: number;
    readonly numberOfCoils: number;
    /**
     * Set success on this command to return a valid response to the emitting server.
     *
     * @param data - Boolean coil data, starting at `coilStartAddress`, of length `numberOfCoils`.
     */
    success(data: Array<boolean>): void;
    /**
     * @hidden
     */
    constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: BoolArraySuccessGetter, failureGetter: FailureGetter, coilAddressGetter: CoilAddressGetter, coilLengthGetter: CoilLengthGetter);
}
export declare class ReadInputStatusCommand extends ModbusCommand<ReadInputStatusCommand> {
    private readonly _inputAddressGetter;
    private readonly _inputLengthGetter;
    readonly inputStartAddress: number;
    readonly numberOfInputs: number;
    /**
     * Set success on this command to return a valid response to the emitting server.
     *
     * @param data - Input status data of requested discrete inputs. `true` = ON, `false` = off
     */
    success(data: Array<boolean>): void;
    /**
     * @hidden
     */
    constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: BoolArraySuccessGetter, failureGetter: FailureGetter, inputAddressGetter: InputAddressGetter, inputLengthGetter: InputLengthGetter);
}
export declare class ReadHoldingRegistersCommand extends ModbusCommand<ReadHoldingRegistersCommand> {
    private readonly _registerAddressGetter;
    private readonly _registerLengthGetter;
    readonly registerStartAddress: number;
    readonly registerLength: number;
    /**
     * Set success on this command to return a valid response to the emitting server.
     *
     * @param data - Array of values of the requested holding registers. Register values are 16 bits. Array length must equal `registerLength`. `data[0]` should be the value of the register at `registerStartAddress`.
     */
    success(data: Uint16Array): void;
    /**
     * @hidden
     */
    constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: Uint16ArraySuccessGetter, failureGetter: FailureGetter, registerAddressGetter: RegisterAddressGetter, registerLengthGetter: RegisterLengthGetter);
}
export declare class ReadInputRegistersCommand extends ModbusCommand<ReadInputRegistersCommand> {
    private readonly _registerAddressGetter;
    private readonly _registerLengthGetter;
    readonly registerStartAddress: number;
    readonly registerLength: number;
    /**
     * Set success on this command to return a valid response to the emitting server.
     *
     * @param data - Array of values of the requested input registers. Register values are 16 bits. Array length must equal `registerLength`. `data[0]` should be the value of the register at `registerStartAddress`.
     */
    success(data: Uint16Array): void;
    /**
     * @hidden
     */
    constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: Uint16ArraySuccessGetter, failureGetter: FailureGetter, registerAddressGetter: RegisterAddressGetter, registerLengthGetter: RegisterLengthGetter);
}
export declare class ForceSingleCoilCommand extends ModbusCommand<ForceSingleCoilCommand> {
    private readonly _coilAddressGetter;
    private readonly _coilStatusGetter;
    readonly coilAddress: number;
    readonly coilStatus: boolean;
    readonly coilStatusAsCoilStatus: CoilStatus;
    /**
     * Set success on this command to return a valid response to the emitting server.
     */
    success(): void;
    /**
     * @hidden
     */
    constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: GenericSuccessGetter, failureGetter: FailureGetter, coilAddressGetter: CoilAddressGetter, coilStatusGetter: CoilStatusGetter);
}
export declare class PresetSingleRegisterCommand extends ModbusCommand<PresetSingleRegisterCommand> {
    private readonly _registerAddressGetter;
    private readonly _registerValueGetter;
    readonly registerAddress: number;
    readonly registerValue: number;
    /**
     * Set success on this command to return a valid response to the emitting server.
     */
    success(): void;
    /**
     * @hidden
     */
    constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: GenericSuccessGetter, failureGetter: FailureGetter, registerAddressGetter: RegisterAddressGetter, registerValueGetter: RegisterValueGetter);
}
export declare class ForceMultipleCoilsCommand extends ModbusCommand<ForceMultipleCoilsCommand> {
    private readonly _coilAddressGetter;
    private readonly _coilLengthGetter;
    private readonly _coilStatusesGetter;
    readonly coilStartAddress: number;
    readonly coilLength: number;
    readonly coilStatuses: boolean[];
    readonly coilStatusesAsCoilStatusArray: CoilStatus[];
    /**
     * Set success on this command to return a valid response to the emitting server.
     */
    success(): void;
    /**
     * @hidden
     */
    constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: GenericSuccessGetter, failureGetter: FailureGetter, coilAddressGetter: CoilAddressGetter, coilLengthGetter: CoilLengthGetter, coilStatusesGetter: CoilStatusesGetter);
}
export declare class PresetMultipleRegistersCommand extends ModbusCommand<PresetMultipleRegistersCommand> {
    private readonly _registerAddressGetter;
    private readonly _registerLengthGetter;
    private readonly _registerValuesGetter;
    readonly registerStartAddress: number;
    readonly registerLength: number;
    readonly registerValues: number[];
    readonly registerValuesAsUint16Array: Uint16Array;
    /**
     * Set success on this command to return a valid response to the emitting server.
     */
    success(): void;
    /**
     * @hidden
     */
    constructor(rawPacket: Buffer, unitIdGetter: UnitIdGetter, functionCodeGetter: FunctionCodeGetter, successGetter: GenericSuccessGetter, failureGetter: FailureGetter, registerAddressGetter: RegisterAddressGetter, registerLengthGetter: RegisterLengthGetter, registerValuesGetter: RegisterValuesGetter);
}
