"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var net_1 = __importDefault(require("net"));
require("../util/typed-event");
var modbus_server_1 = require("../modbus-server");
var modbus_tcp_command_factory_1 = require("./modbus-tcp-command-factory");
var modbus_commands_1 = require("../modbus-commands");
var ModbusTcpServer = /** @class */ (function (_super) {
    __extends(ModbusTcpServer, _super);
    function ModbusTcpServer(options) {
        var _this_1 = _super.call(this) || this;
        _this_1._commandFactory = new modbus_tcp_command_factory_1.ModbusTcpCommandFactory();
        _this_1._options = options;
        _this_1._commandFactory = new modbus_tcp_command_factory_1.ModbusTcpCommandFactory(options);
        _this_1._tcpServer = net_1.default.createServer(function (socket) {
            var _this = _this_1;
            socket.on('data', function (data) {
                try {
                    // Build object from packet
                    var command = _this_1._commandFactory.fromPacket(data);
                    // Listen for success or failure events being emitted from command object
                    command.onComplete.once(function (command) {
                        socket.write(command.responsePacket);
                    });
                    // Determine packet type and emit corresponding event type
                    switch (command.functionCode) {
                        case modbus_commands_1.ModbusFunctionCode.READ_COIL_STATUS:
                            _this.onReadCoilStatus.emit(command);
                            break;
                        case modbus_commands_1.ModbusFunctionCode.READ_INPUT_STATUS:
                            _this.onReadInputStatus.emit(command);
                            break;
                        case modbus_commands_1.ModbusFunctionCode.READ_HOLDING_REGISTERS:
                            _this.onReadHoldingRegisters.emit(command);
                            break;
                        case modbus_commands_1.ModbusFunctionCode.READ_INPUT_REGISTERS:
                            _this.onReadInputRegisters.emit(command);
                            break;
                        case modbus_commands_1.ModbusFunctionCode.FORCE_SINGLE_COIL:
                            _this.onForceSingleCoil.emit(command);
                            break;
                        case modbus_commands_1.ModbusFunctionCode.PRESET_SINGLE_REGISTER:
                            _this.onPresetSingleRegister.emit(command);
                            break;
                        case modbus_commands_1.ModbusFunctionCode.FORCE_MULTIPLE_COILS:
                            _this.onForceMultipleCoils.emit(command);
                            break;
                        case modbus_commands_1.ModbusFunctionCode.PRESET_MULTIPLE_REGISTERS:
                            _this.onPresetMultipleRegisters.emit(command);
                            break;
                    }
                }
                catch (e) {
                    // TODO: Explicit typeguard here, look into changing from try/catch
                    _this.onCommandError.emit(e);
                }
            });
            socket.on('error', function (e) {
                _this.onServerError.emit(e);
            });
        });
        return _this_1;
    }
    ModbusTcpServer.prototype.listen = function (port) {
        this._tcpServer.listen(port);
        return this;
    };
    ModbusTcpServer.prototype.close = function () {
        this._tcpServer.close();
        return this;
    };
    return ModbusTcpServer;
}(modbus_server_1.ModbusServer));
exports.ModbusTcpServer = ModbusTcpServer;
//# sourceMappingURL=modbus-tcp-server.js.map