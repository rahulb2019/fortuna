"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var modbus_commands_1 = require("../modbus-commands");
var modbus_errors_1 = require("../error/modbus-errors");
var simple_modbus_1 = require("../simple-modbus");
describe('ReadCoilStatusCommand tests', function () {
    // 0-1   = Transaction ID
    // 2-3   = Protocol ID (0x0000)
    // 4-5   = Message Length
    // 6     = UnitId
    // 7     = Function Code
    // 8-9   = Coil Start Address (0x0110 = 272)
    // 10-11 = Number of coils to read (0x0025 = 37)
    var validCommandBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x01, 0x01, 0x10, 0x00, 0x25];
    var coilStatuses = [
        true, false, true, true, false, false, true, true,
        true, true, false, true, false, true, true, false,
        false, true, false, false, true, true, false, true,
        false, true, true, true, false, false, false, false,
        true, true, false, true, true
    ];
    var validResponseBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x05, 0x01, 0x05, 0xCD, 0x6B, 0xB2, 0x0E, 0x1B];
    it('should return an instance of ReadCoilStatusCommand', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command).toBeInstanceOf(modbus_commands_1.ReadCoilStatusCommand);
    });
    it('should return the right function code', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.functionCode).toEqual(modbus_commands_1.ModbusFunctionCode.READ_COIL_STATUS);
    });
    it('should return the right coil address (Blank)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.coilStartAddress).toEqual(272);
    });
    it('should return the right coil address (Simple)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: true });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.coilStartAddress).toEqual(272);
    });
    it('should return the right coil address (Modbus)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: false });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.coilStartAddress).toEqual(273);
    });
    it('should return the right coil length', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.numberOfCoils).toEqual(37);
    });
    it('should return the right Unit ID', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.unitId).toEqual(5);
    });
    it('should emit a complete response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success(coilStatuses);
    });
    it('should emit a success response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onSuccess.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success(coilStatuses);
    });
    it('should emit a complete response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x05, 0x81, 0x04];
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should emit a failure response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x05, 0x81, 0x04];
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onFailure.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should throw an error when accessing response packet before success or fail has been called', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(function () {
            var response = command.responsePacket;
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Tried to read response packet, but success or fail has not been called.'));
    });
});
describe('ReadInputStatusCommand tests', function () {
    // 0-1   = Transaction ID
    // 2-3   = Protocol ID (0x0000)
    // 4-5   = Message Length
    // 6     = UnitId
    // 7     = Function Code
    // 8-9   = Input Start Address (0x0110 = 272)
    // 10-11 = Number of inputs to read (0x0016 = 22)
    var validCommandBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x02, 0x01, 0x10, 0x00, 0x16];
    var inputStatuses = [
        false, false, true, true, false, true, false, true,
        true, true, false, true, true, false, true, true,
        true, false, true, false, true, true
    ];
    var validResponseBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x02, 0x03, 0xAC, 0xDB, 0x35];
    var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x05, 0x82, 0x04];
    it('should return an instance of ReadInputStatusCommand', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command).toBeInstanceOf(modbus_commands_1.ReadInputStatusCommand);
    });
    it('should return the right function code', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.functionCode).toEqual(modbus_commands_1.ModbusFunctionCode.READ_INPUT_STATUS);
    });
    it('should return the right input address (Blank)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.inputStartAddress).toEqual(272);
    });
    it('should return the right input address (Simple)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: true });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.inputStartAddress).toEqual(272);
    });
    it('should return the right input address (Modbus)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: false });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.inputStartAddress).toEqual(10273);
    });
    it('should return the right input length', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.numberOfInputs).toEqual(22);
    });
    it('should return the right Unit ID', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.unitId).toEqual(5);
    });
    it('should emit a complete response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success(inputStatuses);
    });
    it('should emit a success response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onSuccess.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success(inputStatuses);
    });
    it('should emit a complete response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should emit a failure response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onFailure.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should throw an error when accessing response packet before success or fail has been called', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(function () {
            var response = command.responsePacket;
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Tried to read response packet, but success or fail has not been called.'));
    });
});
describe('ReadHoldingRegistersCommand tests', function () {
    // 0-1   = Transaction ID
    // 2-3   = Protocol ID (0x0000)
    // 4-5   = Message Length
    // 6     = UnitId
    // 7     = Function Code
    // 8-9   = Holding Register Start Address (0x0110 = 272)
    // 10-11 = Number of registers to read (0x003 = 3)
    var validCommandBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x03, 0x01, 0x10, 0x00, 0x03];
    var registerValues = new Uint16Array([0xAE41, 0x5652, 0x4340]);
    var validResponseBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x05, 0x03, 0x06, 0xAE, 0x41, 0x56, 0x52, 0x43, 0x40];
    var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x05, 0x83, 0x04];
    it('should return an instance of ReadHoldingRegistersCommand', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command).toBeInstanceOf(modbus_commands_1.ReadHoldingRegistersCommand);
    });
    it('should return the right function code', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.functionCode).toEqual(modbus_commands_1.ModbusFunctionCode.READ_HOLDING_REGISTERS);
    });
    it('should return the right register address (Blank)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerStartAddress).toEqual(272);
    });
    it('should return the right register address (Simple)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: true });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerStartAddress).toEqual(272);
    });
    it('should return the right register address (Modbus)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: false });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerStartAddress).toEqual(40273);
    });
    it('should return the right register length', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerLength).toEqual(3);
    });
    it('should return the right Unit ID', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.unitId).toEqual(5);
    });
    it('should emit a complete response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success(registerValues);
    });
    it('should emit a success response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onSuccess.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success(registerValues);
    });
    it('should emit a complete response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should emit a failure response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onFailure.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should throw an error when accessing response packet before success or fail has been called', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(function () {
            var response = command.responsePacket;
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Tried to read response packet, but success or fail has not been called.'));
    });
});
describe('ReadInputRegistersCommand tests', function () {
    // 0-1   = Transaction ID
    // 2-3   = Protocol ID (0x0000)
    // 4-5   = Message Length
    // 6     = UnitId
    // 7     = Function Code
    // 8-9   = Input Register Start Address (0x0110 = 272)
    // 10-11 = Number of registers to read (0x003 = 3)
    var validCommandBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x04, 0x01, 0x10, 0x00, 0x03];
    var registerValues = new Uint16Array([0xAE41, 0x5652, 0x4340]);
    var validResponseBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x05, 0x04, 0x06, 0xAE, 0x41, 0x56, 0x52, 0x43, 0x40];
    var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x05, 0x84, 0x04];
    it('should return an instance of ReadInputRegistersCommand', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command).toBeInstanceOf(modbus_commands_1.ReadInputRegistersCommand);
    });
    it('should return the right function code', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.functionCode).toEqual(modbus_commands_1.ModbusFunctionCode.READ_INPUT_REGISTERS);
    });
    it('should return the right register address (Blank)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerStartAddress).toEqual(272);
    });
    it('should return the right register address (Simple)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: true });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerStartAddress).toEqual(272);
    });
    it('should return the right register address (Modbus)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: false });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerStartAddress).toEqual(30273);
    });
    it('should return the right register length', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerLength).toEqual(3);
    });
    it('should return the right Unit ID', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.unitId).toEqual(5);
    });
    it('should emit a complete response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success(registerValues);
    });
    it('should emit a success response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onSuccess.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success(registerValues);
    });
    it('should emit a complete response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should emit a failure response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onFailure.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should throw an error when accessing response packet before success or fail has been called', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(function () {
            var response = command.responsePacket;
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Tried to read response packet, but success or fail has not been called.'));
    });
});
describe('PresetSingleRegisterCommand tests', function () {
    // 0-1   = Transaction ID
    // 2-3   = Protocol ID (0x0000)
    // 4-5   = Message Length
    // 6     = UnitId
    // 7     = Function Code
    // 8-9   = Register Address (0x0110 = 272)
    // 10-11 = Register Value (0x0110 = 272)
    var validCommandBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x11, 0x06, 0x01, 0x10, 0x01, 0x10];
    var validResponseBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x11, 0x06, 0x01, 0x10, 0x01, 0x10];
    it('should return an instance of PresetSingleRegisterCommand', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command).toBeInstanceOf(modbus_commands_1.PresetSingleRegisterCommand);
    });
    it('should return the right function code', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.functionCode).toEqual(modbus_commands_1.ModbusFunctionCode.PRESET_SINGLE_REGISTER);
    });
    it('should return the right register address (Blank)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerAddress).toEqual(272);
    });
    it('should return the right register address (Simple)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: true });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerAddress).toEqual(272);
    });
    it('should return the right register address (Modbus)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: false });
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerAddress).toEqual(40273);
    });
    it('should return the right register value', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.registerValue).toEqual(272);
    });
    it('should return the right Unit ID', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(command.unitId).toEqual(0x11);
    });
    it('should emit a complete response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success();
    });
    it('should emit a success response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onSuccess.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success();
    });
    it('should emit a complete response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x11, 0x86, 0x04];
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should emit a failure response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x11, 0x86, 0x04];
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        command.onFailure.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should throw an error when accessing response packet before success or fail has been called', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validCommandBytes));
        expect(function () {
            var response = command.responsePacket;
            // }).toThrowError(ModbusCommandError)
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Tried to read response packet, but success or fail has not been called.'));
    });
});
describe('ForceSingleCoilCommand tests', function () {
    // 0-1   = Transaction ID
    // 2-3   = Protocol ID (0x0000)
    // 4-5   = Message Length
    // 6     = UnitId
    // 7     = Function Code
    // 8-9   = Coil Address (0x0110 = 272)
    // 10-11 = Coil Status (0xFF00 = ON, 0x0000 = OFF)
    var coilOnBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x05, 0x01, 0x10, 0xFF, 0x00];
    var coilOffBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x05, 0x01, 0x10, 0x00, 0x00];
    var coilInvalidBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x05, 0x01, 0x10, 0x11, 0x11];
    var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x05, 0x85, 0x04];
    it('should return an instance of ForceSingleCoilCommand', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(command).toBeInstanceOf(modbus_commands_1.ForceSingleCoilCommand);
    });
    it('should return the right function code', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(command.functionCode).toEqual(modbus_commands_1.ModbusFunctionCode.FORCE_SINGLE_COIL);
    });
    it('should return the right coil address (Blank)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(command.coilAddress).toEqual(272);
    });
    it('should return the right coil address (Simple)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: true });
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(command.coilAddress).toEqual(272);
    });
    it('should return the right coil address (Modbus)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: false });
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(command.coilAddress).toEqual(273);
    });
    it('should return the right Unit ID', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(command.unitId).toEqual(0x05);
    });
    it('should return coil ON status (boolean)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(command.coilStatus).toEqual(true);
    });
    it('should return coil OFF status (boolean)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOffBytes));
        expect(command.coilStatus).toEqual(false);
    });
    it('should return coil ON status (enum)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(command.coilStatusAsCoilStatus).toEqual(modbus_commands_1.CoilStatus.ON);
    });
    it('should return coil OFF status (enum)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOffBytes));
        expect(command.coilStatusAsCoilStatus).toEqual(modbus_commands_1.CoilStatus.OFF);
    });
    it('should throw on an invalid coil status', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(coilInvalidBytes));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('FORCE_SINGLE_COIL - Invalid coil status received'));
    });
    it('should emit a complete response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(coilOnBytes));
            done();
        });
        command.success();
    });
    it('should emit a success response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOffBytes));
        command.onSuccess.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(coilOffBytes));
            done();
        });
        command.success();
    });
    it('should emit a complete response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should emit a failure response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        command.onFailure.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should throw an error when accessing response packet before success or fail has been called', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(coilOnBytes));
        expect(function () {
            var response = command.responsePacket;
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Tried to read response packet, but success or fail has not been called.'));
    });
});
describe('ForceMultipleCoilsCommand tests', function () {
    // 0-1   = Transaction ID
    // 2-3   = Protocol ID (0x0000)
    // 4-5   = Message Length
    // 6     = UnitId
    // 7     = Function Code
    // 8-9   = Coil Start Address (0x0110 = 272)
    // 10-11 = Coil Length (000A = 10)
    // 12    = Bytes to follow (0x02 = 2)
    // 13-14 = Coil Data
    var validRequestBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x05, 0x0F, 0x01, 0x10, 0x00, 0x0A, 0x02, 0xCD, 0x01];
    var invalidRequestBytes1 = [0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x05, 0x0F, 0x01, 0x10, 0x00, 0x0A, 0x03, 0xCD, 0x01];
    var invalidRequestBytes2 = [0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x05, 0x0F, 0x01, 0x10, 0x00, 0x0A, 0x02, 0xCD, 0x01, 0x00];
    var invalidRequestBytes3 = [0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x05, 0x0F, 0x01, 0x10, 0x00, 0xFF, 0x02, 0xCD, 0x01];
    var coilStatuses = [true, false, true, true, false, false, true, true, true, false];
    var coilStatusesEnum = [modbus_commands_1.CoilStatus.ON, modbus_commands_1.CoilStatus.OFF, modbus_commands_1.CoilStatus.ON, modbus_commands_1.CoilStatus.ON, modbus_commands_1.CoilStatus.OFF, modbus_commands_1.CoilStatus.OFF, modbus_commands_1.CoilStatus.ON, modbus_commands_1.CoilStatus.ON, modbus_commands_1.CoilStatus.ON, modbus_commands_1.CoilStatus.OFF];
    var validResponseBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x0F, 0x01, 0x10, 0x00, 0x0A];
    var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x05, 0x8F, 0x04];
    it('should return an instance of ForceMultipleCoilsCommand', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command).toBeInstanceOf(modbus_commands_1.ForceMultipleCoilsCommand);
    });
    it('should return the right function code', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.functionCode).toEqual(modbus_commands_1.ModbusFunctionCode.FORCE_MULTIPLE_COILS);
    });
    it('should return the right coil address (Blank)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.coilStartAddress).toEqual(272);
    });
    it('should return the right coil address (Simple)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: true });
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.coilStartAddress).toEqual(272);
    });
    it('should return the right coil address (Modbus)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: false });
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.coilStartAddress).toEqual(273);
    });
    it('should return requested coil statuses (boolean)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.coilStatuses).toEqual(coilStatuses);
    });
    it('should return requested coil statuses (enum)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.coilStatusesAsCoilStatusArray).toEqual(coilStatusesEnum);
    });
    it('should return correct coil length', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.coilLength).toEqual(10);
    });
    it('should throw on an invalid coil length', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(invalidRequestBytes1));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('FORCE_MULTIPLE_COILS - Invalid coil status command received'));
    });
    it('should throw on an invalid coil length 2', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(invalidRequestBytes2));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('FORCE_MULTIPLE_COILS - Invalid coil status command received'));
    });
    it('should throw on an invalid coil length 3', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(invalidRequestBytes3));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('FORCE_MULTIPLE_COILS - Invalid coil status command received'));
    });
    it('should emit a complete response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success();
    });
    it('should emit a success response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        command.onSuccess.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success();
    });
    it('should emit a complete response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should emit a failure response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        command.onFailure.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should throw an error when accessing response packet before success or fail has been called', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(function () {
            var response = command.responsePacket;
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Tried to read response packet, but success or fail has not been called.'));
    });
});
describe('PresetMultipleRegistersCommand tests', function () {
    // 0-1   = Transaction ID
    // 2-3   = Protocol ID (0x0000)
    // 4-5   = Message Length
    // 6     = UnitId
    // 7     = Function Code
    // 8-9   = Register Start Address (0x0110 = 272)
    // 10-11 = Register Length (000A = 10)
    // 12    = Bytes to follow (0x04 = 4)
    // 13-16 = Register values
    var validRequestBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x05, 0x10, 0x01, 0x10, 0x00, 0x02, 0x04, 0x00, 0x0A, 0x01, 0x02];
    var invalidRequestBytes1 = [0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x05, 0x10, 0x01, 0x10, 0x00, 0x02, 0x05, 0x00, 0x0A, 0x01, 0x02];
    var invalidRequestBytes2 = [0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x05, 0x10, 0x01, 0x10, 0x00, 0x02, 0x04, 0x00, 0x0A, 0x01, 0x02, 0x00];
    var invalidRequestBytes3 = [0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x05, 0x10, 0x01, 0x10, 0x00, 0x03, 0x04, 0x00, 0x0A, 0x01, 0x02];
    var registerValues = [0x000A, 0x0102];
    var registerValuesUint16 = Uint16Array.from([0x000A, 0x0102]);
    var validResponseBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x10, 0x01, 0x10, 0x00, 0x02];
    var failureBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x05, 0x90, 0x04];
    it('should return an instance of PresetMultipleRegistersCommand', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command).toBeInstanceOf(modbus_commands_1.PresetMultipleRegistersCommand);
    });
    it('should return the right function code', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.functionCode).toEqual(modbus_commands_1.ModbusFunctionCode.PRESET_MULTIPLE_REGISTERS);
    });
    it('should return the right register address (Blank)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.registerStartAddress).toEqual(272);
    });
    it('should return the right register address (Simple)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: true });
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.registerStartAddress).toEqual(272);
    });
    it('should return the right register address (Modbus)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory({ simpleAddressing: false });
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.registerStartAddress).toEqual(40273);
    });
    it('should return requested register values (number)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.registerValues).toEqual(registerValues);
    });
    it('should return requested register values (Uint16Array)', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.registerValuesAsUint16Array).toEqual(registerValuesUint16);
    });
    it('should return correct register length', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(command.registerLength).toEqual(2);
    });
    it('should throw on an invalid register length', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(invalidRequestBytes1));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('PRESET_MULTIPLE_REGISTERS - Invalid register command received'));
    });
    it('should throw on an invalid register length 2', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(invalidRequestBytes2));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('PRESET_MULTIPLE_REGISTERS - Invalid register command received'));
    });
    it('should throw on an invalid register length 3', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(invalidRequestBytes3));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('PRESET_MULTIPLE_REGISTERS - Invalid register command received'));
    });
    it('should emit a complete response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success();
    });
    it('should emit a success response on success', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        command.onSuccess.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(validResponseBytes));
            done();
        });
        command.success();
    });
    it('should emit a complete response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        command.onComplete.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should emit a failure response on failure', function (done) {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        command.onFailure.on(function (command) {
            expect(command.responsePacket).toEqual(Buffer.from(failureBytes));
            done();
        });
        command.fail(modbus_commands_1.ModbusCommandException.SERVER_DEVICE_FAILURE);
    });
    it('should throw an error when accessing response packet before success or fail has been called', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var command = commandFactory.fromPacket(Buffer.from(validRequestBytes));
        expect(function () {
            var response = command.responsePacket;
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Tried to read response packet, but success or fail has not been called.'));
    });
});
describe('Malformed packet tests', function () {
    it('should throw a command exception on invalid fc', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var invalidCommandBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x11, 0x14, 0x00, 0x00, 0x00, 0x03];
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(invalidCommandBytes));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Function code not implemented'));
    });
    it('should throw a command exception on short packet', function () {
        var commandFactory = new simple_modbus_1.ModbusTcp.CommandFactory();
        var invalidCommandBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x11, 0x14, 0x00, 0x00];
        expect(function () {
            var command = commandFactory.fromPacket(Buffer.from(invalidCommandBytes));
        }).toThrowError(new modbus_errors_1.ModbusCommandError('Packet length too short'));
    });
    // It should error when a packet has the wrong length byte
});
//# sourceMappingURL=tcp-commands.test.js.map