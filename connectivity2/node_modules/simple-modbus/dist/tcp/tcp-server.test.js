"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var modbus_errors_1 = require("../error/modbus-errors");
var net = require('net');
jest.mock('net');
var modbus_tcp_server_1 = require("./modbus-tcp-server");
var modbus_commands_1 = require("../modbus-commands");
describe('Server tests', function () {
    beforeEach(function () {
        jest.clearAllMocks();
        net.__reset();
    });
    it('should return a server', function () {
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        expect(server).toBeInstanceOf(modbus_tcp_server_1.ModbusTcpServer);
    });
    it('should close TCP server on call to close method', function () {
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        expect(net.__server.close.mock.calls.length).toBe(0);
        server.close();
        expect(net.__server.close.mock.calls.length).toBe(1);
    });
    it('should emit a server error on TCP server error', function (done) {
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onServerError.on(function (e) {
            expect(e).toBeInstanceOf(Error);
            expect(e.message).toEqual('Server Error');
            done();
        });
        net.__socket.emit('error', new Error('Server Error'));
    });
    it('should correctly pass options to command factory', function () {
        var server = new modbus_tcp_server_1.ModbusTcpServer();
        expect(server._commandFactory._options).toBeUndefined();
        var options = {};
        server = new modbus_tcp_server_1.ModbusTcpServer(options);
        expect(server._commandFactory._options).toEqual(options);
        options = { simpleAddressing: false };
        server = new modbus_tcp_server_1.ModbusTcpServer(options);
        expect(server._commandFactory._options).toEqual(options);
        options = { simpleAddressing: true };
        server = new modbus_tcp_server_1.ModbusTcpServer(options);
        expect(server._commandFactory._options).toEqual(options);
    });
    it('should use simple addressing when simpleAddressing is blank', function (done) {
        var validRequest = Buffer.from([
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x11,
            0x06,
            0x00,
            0x00,
            0x00,
            0x03
        ]);
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onPresetSingleRegister.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.PresetSingleRegisterCommand);
            expect(command.registerAddress).toEqual(0);
            done();
        });
        net.__socket.emit('data', validRequest);
    });
    it('should use simple addressing when simpleAddressing is true', function (done) {
        var validRequest = Buffer.from([
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x11,
            0x06,
            0x00,
            0x00,
            0x00,
            0x03
        ]);
        var server = new modbus_tcp_server_1.ModbusTcpServer({ simpleAddressing: true }).listen(502);
        server.onPresetSingleRegister.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.PresetSingleRegisterCommand);
            expect(command.registerAddress).toEqual(0);
            done();
        });
        net.__socket.emit('data', validRequest);
    });
    it('should use Modbus addressing when simpleAddressing is false', function (done) {
        var validRequest = Buffer.from([
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x11,
            0x06,
            0x00,
            0x00,
            0x00,
            0x03
        ]);
        var server = new modbus_tcp_server_1.ModbusTcpServer({ simpleAddressing: false }).listen(502);
        server.onPresetSingleRegister.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.PresetSingleRegisterCommand);
            expect(command.registerAddress).toEqual(40001);
            done();
        });
        net.__socket.emit('data', validRequest);
    });
});
describe('Server command tests', function () {
    beforeEach(function () {
        jest.clearAllMocks();
        net.__reset();
    });
    it('should emit a ReadCoilStatusCommand and write a response', function (done) {
        var validCommandBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x05,
            0x01,
            0x01,
            0x10,
            0x00,
            0x25
        ];
        var coilValues = [
            true,
            false,
            true,
            true,
            false,
            false,
            true,
            true,
            true,
            true,
            false,
            true,
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            false,
            true,
            true,
            false,
            true,
            false,
            true,
            true,
            true,
            false,
            false,
            false,
            false,
            true,
            true,
            false,
            true,
            true
        ];
        var validResponseBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x08,
            0x05,
            0x01,
            0x05,
            0xcd,
            0x6b,
            0xb2,
            0x0e,
            0x1b
        ];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onReadCoilStatus.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.ReadCoilStatusCommand);
            net.__socket.on('write', function (data) {
                expect(data).toEqual(Buffer.from(validResponseBytes));
                done();
            });
            command.success(coilValues);
        });
        net.__socket.emit('data', Buffer.from(validCommandBytes));
    });
    it('should emit a ReadInputStatusCommand and write a response', function (done) {
        var validCommandBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x05,
            0x02,
            0x01,
            0x10,
            0x00,
            0x16
        ];
        var inputStatuses = [
            false,
            false,
            true,
            true,
            false,
            true,
            false,
            true,
            true,
            true,
            false,
            true,
            true,
            false,
            true,
            true,
            true,
            false,
            true,
            false,
            true,
            true
        ];
        var validResponseBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x05,
            0x02,
            0x03,
            0xac,
            0xdb,
            0x35
        ];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onReadInputStatus.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.ReadInputStatusCommand);
            net.__socket.on('write', function (data) {
                expect(data).toEqual(Buffer.from(validResponseBytes));
                done();
            });
            command.success(inputStatuses);
        });
        net.__socket.emit('data', Buffer.from(validCommandBytes));
    });
    it('should emit a ReadHoldingRegistersCommand and write a response', function (done) {
        var validCommandBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x05,
            0x03,
            0x01,
            0x10,
            0x00,
            0x03
        ];
        var registerValues = new Uint16Array([0xae41, 0x5652, 0x4340]);
        var validResponseBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x09,
            0x05,
            0x03,
            0x06,
            0xae,
            0x41,
            0x56,
            0x52,
            0x43,
            0x40
        ];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onReadHoldingRegisters.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.ReadHoldingRegistersCommand);
            net.__socket.on('write', function (data) {
                expect(data).toEqual(Buffer.from(validResponseBytes));
                done();
            });
            command.success(registerValues);
        });
        net.__socket.emit('data', Buffer.from(validCommandBytes));
    });
    it('should emit a ReadInputRegistersCommand and write a response', function (done) {
        var validCommandBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x05,
            0x04,
            0x01,
            0x10,
            0x00,
            0x03
        ];
        var registerValues = new Uint16Array([0xae41, 0x5652, 0x4340]);
        var validResponseBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x09,
            0x05,
            0x04,
            0x06,
            0xae,
            0x41,
            0x56,
            0x52,
            0x43,
            0x40
        ];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onReadInputRegisters.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.ReadInputRegistersCommand);
            net.__socket.on('write', function (data) {
                expect(data).toEqual(Buffer.from(validResponseBytes));
                done();
            });
            command.success(registerValues);
        });
        net.__socket.emit('data', Buffer.from(validCommandBytes));
    });
    it('should emit a ForceSingleCoilCommand and write a response', function (done) {
        var coilOnBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x05, 0x01, 0x10, 0xff, 0x00];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onForceSingleCoil.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.ForceSingleCoilCommand);
            net.__socket.on('write', function (data) {
                expect(data).toEqual(Buffer.from(coilOnBytes));
                done();
            });
            command.success();
        });
        net.__socket.emit('data', Buffer.from(coilOnBytes));
    });
    it('should emit an error when invalid ForceSingleCoilCommand is sent', function (done) {
        var coilFailBytes = [0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x05, 0x05, 0x01, 0x10, 0x11, 0x11];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onCommandError.on(function (e) {
            expect(e).toBeInstanceOf(modbus_errors_1.ModbusCommandError);
            expect(e.message).toEqual('FORCE_SINGLE_COIL - Invalid coil status received');
            expect(e.requestBytes).toEqual(Buffer.from(coilFailBytes));
            done();
        });
        net.__socket.emit('data', Buffer.from(coilFailBytes));
    });
    it('should emit a PresetSingleRegisterCommand and write a response', function (done) {
        var validRequest = Buffer.from([
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x11,
            0x06,
            0x00,
            0x00,
            0x00,
            0x03
        ]);
        var validResponse = Buffer.from([
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x11,
            0x06,
            0x00,
            0x00,
            0x00,
            0x03
        ]);
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onPresetSingleRegister.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.PresetSingleRegisterCommand);
            net.__socket.on('write', function (data) {
                expect(data).toEqual(validResponse);
                done();
            });
            command.success();
        });
        net.__socket.emit('data', validRequest);
    });
    it('should emit a ForceMultipleCoilsCommand and write a response', function (done) {
        var validRequestBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x08,
            0x05,
            0x0f,
            0x01,
            0x10,
            0x00,
            0x0a,
            0x02,
            0xcd,
            0x01
        ];
        var coilValues = [true, false, true, true, false, false, true, true, true, false];
        var validResponseBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x05,
            0x0f,
            0x01,
            0x10,
            0x00,
            0x0a
        ];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onForceMultipleCoils.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.ForceMultipleCoilsCommand);
            expect(command.coilStatuses).toEqual(coilValues);
            net.__socket.on('write', function (data) {
                expect(data).toEqual(Buffer.from(validResponseBytes));
                done();
            });
            command.success();
        });
        net.__socket.emit('data', Buffer.from(validRequestBytes));
    });
    it('should emit an error when invalid ForceMultipleCoilsCommand is sent', function (done) {
        var coilFailBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x08,
            0x05,
            0x0f,
            0x01,
            0x10,
            0x00,
            0x0a,
            0x03,
            0xcd,
            0x01
        ];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onCommandError.on(function (e) {
            expect(e).toBeInstanceOf(modbus_errors_1.ModbusCommandError);
            expect(e.message).toEqual('FORCE_MULTIPLE_COILS - Invalid coil status command received');
            expect(e.requestBytes).toEqual(Buffer.from(coilFailBytes));
            done();
        });
        net.__socket.emit('data', Buffer.from(coilFailBytes));
    });
    it('should emit a PresetMultipleRegistersCommand and write a response', function (done) {
        var validRequestBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x0b,
            0x05,
            0x10,
            0x01,
            0x10,
            0x00,
            0x02,
            0x04,
            0x00,
            0x0a,
            0x01,
            0x02
        ];
        var registerValues = [0x000a, 0x0102];
        var validResponseBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x06,
            0x05,
            0x10,
            0x01,
            0x10,
            0x00,
            0x02
        ];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onPresetMultipleRegisters.on(function (command) {
            expect(command).toBeInstanceOf(modbus_commands_1.PresetMultipleRegistersCommand);
            expect(command.registerValues).toEqual(registerValues);
            net.__socket.on('write', function (data) {
                expect(data).toEqual(Buffer.from(validResponseBytes));
                done();
            });
            command.success();
        });
        net.__socket.emit('data', Buffer.from(validRequestBytes));
    });
    it('should emit an error when invalid PresetMultipleRegistersCommand is sent', function (done) {
        var registerFailBytes = [
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x0b,
            0x05,
            0x10,
            0x01,
            0x10,
            0x00,
            0x02,
            0x05,
            0x00,
            0x0a,
            0x01,
            0x02
        ];
        var server = new modbus_tcp_server_1.ModbusTcpServer().listen(502);
        server.onCommandError.on(function (e) {
            expect(e).toBeInstanceOf(modbus_errors_1.ModbusCommandError);
            expect(e.message).toEqual('PRESET_MULTIPLE_REGISTERS - Invalid register command received');
            expect(e.requestBytes).toEqual(Buffer.from(registerFailBytes));
            done();
        });
        net.__socket.emit('data', Buffer.from(registerFailBytes));
    });
    // TODO: rewrite test names and test close and listen methods
});
//# sourceMappingURL=tcp-server.test.js.map